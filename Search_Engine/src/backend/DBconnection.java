package backend;

import java.sql.*;
import java.util.Calendar;
import java.util.HashSet;
import java.util.Set;

import org.postgresql.util.PSQLException;

public class DBconnection {
    public Connection con;
	

    public void initialize(Credentials cred) throws SQLException {	
        Connection connection = DriverManager.getConnection("jdbc:postgresql://"+cred.getHost()+":"+cred.getPort()+"/"+cred.getDatabase(), cred.getUsername(), cred.getPassword());
        this.con= connection;
    }

    public Connection getCon() {
        return con;
    }

    public void dropTables() throws SQLException{
        Statement stmt = con.createStatement();
        //String drop_database = "DROP DATABASE " + database
        String features_bm25_view = "DROP MATERIALIZED VIEW  IF EXISTS features_bm25 ";
        String features_tfidf_view = "DROP MATERIALIZED VIEW  IF EXISTS features_tfidf ";
        String features_combined_view = "DROP MATERIALIZED VIEW  IF EXISTS features_combined ";
        String viewcountdocumentterm_table = "DROP MATERIALIZED VIEW  IF EXISTS avgTerms ";
        String viewcountdocument_table = "DROP MATERIALIZED VIEW  IF EXISTS cdocs";
        String features_table = "DROP TABLE IF EXISTS image_features ";
        String images_features_table = "DROP TABLE IF EXISTS features ";
        String documents_table = "DROP TABLE IF EXISTS documents ";
        String ads_table = "DROP TABLE IF EXISTS ads ";
        String adclicks_table = "DROP TABLE IF EXISTS adclicks ";
        String images_table = "DROP TABLE IF EXISTS images ";
        String links_table = "DROP TABLE IF EXISTS links CASCADE";
        String index = "DROP TABLE IF EXISTS idx_term CASCADE";
        String index2 = "DROP TABLE IF EXISTS idx_url CASCADE";
        //stmt.execute(drop_database);
        stmt.execute(features_bm25_view);
        stmt.execute(features_tfidf_view);
        stmt.execute(features_combined_view);
        stmt.execute(viewcountdocumentterm_table);
        stmt.execute(viewcountdocument_table);
        stmt.execute(features_table);
        stmt.execute(images_features_table);
        stmt.execute(documents_table);
        stmt.execute(images_table);
        stmt.execute(links_table);
        stmt.execute(index);
        stmt.execute(index2);
        stmt.execute(ads_table);
        stmt.execute(adclicks_table);
    }

    public  void createTables() throws SQLException {
  
        Statement stmt = con.createStatement();
        //String create_database= "CREATE DATABASE " + database;
        String features_table = "CREATE TABLE IF NOT EXISTS features(docid INT, term varchar(128), term_frequency INT, tf FLOAT, idf FLOAT, score FLOAT, ntf FLOAT,nidf FLOAT, nscore FLOAT, PRIMARY KEY(docid , term))";
        String image_features_table = "CREATE TABLE IF NOT EXISTS image_features(imageid INT, term varchar(128),distance FLOAT, PRIMARY KEY(imageid , term))";
        String index = "CREATE INDEX IF NOT EXISTS idx_term ON features(term);";
        String documents_table = "CREATE TABLE IF NOT EXISTS documents(docid INT ,url varchar(512) NOT NULL UNIQUE, crawled_on_date DATE,countterms INT,pagerank FLOAT, language varchar(32),txt text, PRIMARY KEY(docid))";
        String images_table = "CREATE TABLE IF NOT EXISTS images(imageid INT ,url varchar(512) NOT NULL UNIQUE, PRIMARY KEY(imageid))";
        String index2 = "CREATE INDEX IF NOT EXISTS idx_url ON documents(url);";
        String links_table = "CREATE TABLE IF NOT EXISTS links(from_docid INT, to_docid INT, PRIMARY KEY(from_docid , to_docid))";
        String adtable = "\r\n" + 
        		"CREATE TABLE IF NOT EXISTS public.ads\r\n" + 
        		"(\r\n" + 
        		"    adlink character varying(520) COLLATE pg_catalog.\"default\",\r\n" + 
        		"    adsid integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),\r\n" + 
        		"    budget double precision,\r\n" + 
        		"    clickcost double precision,\r\n" + 
        		"    terms character varying(250) COLLATE pg_catalog.\"default\",\r\n" + 
        		"    company character varying COLLATE pg_catalog.\"default\",\r\n" + 
        		"    addescription character varying(250) COLLATE pg_catalog.\"default\",\r\n" + 
        		"    currentclicks double precision DEFAULT 0,\r\n" + 
        		"    imagelinks character varying(520) COLLATE pg_catalog.\"default\",\r\n" + 
        		"    CONSTRAINT ads_pkey PRIMARY KEY (adsid)\r\n" + 
        		")\r\n" ;
        
       String adclicks = "CREATE TABLE IF NOT EXISTS public.adclicks\r\n" + 
       "        (\r\n" + 
       "            clickdate date,\r\n" + 
       "            adid integer,\r\n" + 
       "            idclick integer NOT NULL,\r\n" + 
       "            CONSTRAINT adclicks_pkey PRIMARY KEY (idclick)\r\n" + 
       "        )";
        //stmt.execute(create_database);
        stmt.execute(features_table);
        stmt.execute(image_features_table);
        stmt.execute(documents_table);
        stmt.execute(images_table);
        stmt.execute(links_table);
        stmt.execute(index);
        stmt.execute(index2);
        stmt.execute(adtable);
        stmt.execute(adclicks);
    }

    public  void insertIntoFeatures(int docid, String term , int term_frequency) throws SQLException {
        Statement stmt = con.createStatement();
        String insert = String.format("INSERT INTO features VALUES(%d,'%s',%d)",docid,term,term_frequency);
        stmt.executeUpdate(insert);

    }
    
    public  void insertIntoImageFeatures(int imageid, String term , double score) throws SQLException {
        Statement stmt = con.createStatement();
        String insert = String.format("INSERT INTO image_features VALUES(%d,'%s'",imageid,term,score);
        insert=insert+","+score+")";
        stmt.executeUpdate(insert);

    }
    
    public int getNextDocID() throws SQLException {
   	 	PreparedStatement getNextDocID = con.prepareStatement("SELECT MAX(docid) FROM documents ");
   	 	ResultSet result =getNextDocID.executeQuery();
   	 	int nextDocID = 0;
   	 	if(result.next()) {
   	 	 nextDocID = result.getInt("max");
   	 	}
   	 	result.close();
    	return nextDocID+1;	
    }
    
    public int getNextImageID() throws SQLException {
   	 	PreparedStatement getNextImageID = con.prepareStatement("SELECT MAX(imageid) FROM images ");
   	 	ResultSet result =getNextImageID.executeQuery();
   	 	int nextImageID = 0;
   	 	if(result.next()) {
   	 	 nextImageID = result.getInt("max");
   	 	}
   	 	result.close();
    	return nextImageID+1;	
    }
    
	public int lookupDocID(String url) throws SQLException {
		PreparedStatement checkIfInserted = con.prepareStatement("SELECT * FROM documents WHERE url =?");
		checkIfInserted.setString(1, url);
		ResultSet check = checkIfInserted.executeQuery();
		int docid;
		if (check.next()) {
		    docid = check.getInt("docid");
			return docid;
		}
		
		else {
			docid=-1;
		}
		check.close();
		return docid;
	}
	
	public int lookupImageID(String url) throws SQLException {
		PreparedStatement checkIfInserted = con.prepareStatement("SELECT * FROM images WHERE url =?");
		checkIfInserted.setString(1, url);
		ResultSet check = checkIfInserted.executeQuery();
		
		if (check.next()) {
			int imageid = check.getInt("imageid");
			return imageid;
		}
		else return -1;
	}
	
	public String lookupDocUrl(int docid) throws SQLException {
		PreparedStatement checkIfInserted = con.prepareStatement("SELECT * FROM documents WHERE docid =?");
		checkIfInserted.setInt(1, docid);
		ResultSet check = checkIfInserted.executeQuery();
		
		if (check.next()) {
			String url = check.getString("url");
			return url;
		}
		else return null;
	}

	public void insertDocument(int from_docid, String url, java.sql.Date crawled_on_date) throws SQLException {
		boolean hasNotBeenInserted = true;
		while (hasNotBeenInserted) {

			con.setAutoCommit(false);
			con.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
			Savepoint save_insert = con.setSavepoint();
			try {
				// get the docid or create a new one
				int to_docid = lookupDocID(url);
				if (to_docid == -1) {
					// insert into the documents table
					to_docid = getNextDocID();
					PreparedStatement insertDocument = con.prepareStatement("INSERT INTO documents VALUES(?,?,?)");
					insertDocument.setInt(1, to_docid);
					insertDocument.setString(2, url);
					insertDocument.setDate(3, crawled_on_date);
					insertDocument.executeUpdate();


				}

				// insert into links table (from_docid is -1 when url is one of the starting
				// urls)
				if (!(from_docid == -1)) {
					Statement insertLink = con.createStatement();
					String insert = String.format("INSERT INTO links VALUES(%d,%d)", from_docid, to_docid);
					insertLink.executeUpdate(insert);
				}
				hasNotBeenInserted=false;
			} catch (PSQLException e) {
				con.rollback(save_insert);
				hasNotBeenInserted=true;
			}

			con.commit();
			con.setAutoCommit(true);

		}

	}
	
	public boolean insertImage(String url) throws SQLException {
		boolean needToInsertFeatures=false;
		boolean hasNotBeenInserted = true;
		while (hasNotBeenInserted) {

			con.setAutoCommit(false);
			con.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
			Savepoint save_insert = con.setSavepoint();
			try {
				// get the imageid or create a new one
				int imageid = lookupImageID(url);
				if (imageid == -1) {
					needToInsertFeatures=true;
					// insert into the images table
					imageid = getNextImageID();
					PreparedStatement insertImage = con.prepareStatement("INSERT INTO images VALUES(?,?)");
					insertImage.setInt(1, imageid);
					insertImage.setString(2, url);
					insertImage.executeUpdate();
				}
				hasNotBeenInserted=false;
			} catch (PSQLException e) {
				//System.out.println("Insert image: need to rollback  " + e.getMessage());
				con.rollback(save_insert);
				hasNotBeenInserted=true;
			}

			con.commit();
			con.setAutoCommit(true);

		}
		return needToInsertFeatures;

	}
	

	
	
	public ResultSet uncrawledDocuments() throws SQLException {
		PreparedStatement uncrawledDocuments = con.prepareStatement("SELECT * FROM documents WHERE crawled_on_date IS NULL ORDER BY docid");
		ResultSet docs = uncrawledDocuments.executeQuery();
		return docs;
		
	}
	
	public void setCrawled(int docid) throws SQLException {
		java.sql.Date date = new java.sql.Date(Calendar.getInstance().getTime().getTime());
		PreparedStatement setCrawled = con.prepareStatement("UPDATE documents SET crawled_on_date = ? WHERE docid=?" );
		setCrawled.setInt(2, docid);
		setCrawled.setDate(1, date);
		setCrawled.executeUpdate();
	}
	
	public void setLanguage(int docid, String lang) throws SQLException {
		PreparedStatement setLanguage = con.prepareStatement("UPDATE documents SET language = ? WHERE docid=?" );
		setLanguage.setInt(2, docid);
		setLanguage.setString(1, lang);
		setLanguage.executeUpdate();
	}

	public void setText(int docid, String text) throws SQLException {
		PreparedStatement setText = con.prepareStatement("UPDATE documents SET txt = ? WHERE docid=?" );
		setText.setInt(2, docid);
		setText.setString(1, text);
		setText.executeUpdate();
	}
    public int updateIDF() throws SQLException {
        Statement stmt = con.createStatement();
        int updated = stmt.executeUpdate("update features as b\n" +
                "set idf=log( (select count(distinct(docid)) from documents) /  \n" +
                "\t\t\t( select count(docid) from features as a where a.term = b.term))");
        return updated;
    }
    

    public int updateTF() throws SQLException {
        Statement stmt = con.createStatement();
        int updated = stmt.executeUpdate("update features \n" +
                "set tf = (1+log( term_frequency))\n");
        return updated;
    }

    public int updateScore() throws SQLException {
        Statement stmt = con.createStatement();
        int updated = stmt.executeUpdate("update features \n" +
                "set score=tf*idf\n");
        return updated;
    }
    public int updatecountterms() throws SQLException {
        Statement stmt = con.createStatement();
        int updated = stmt.executeUpdate("with cte as (select docid as id, count(term) as ct \n" + 
        		"	FROM public.features group by id) \n" + 
        		"	UPDATE documents \n" + 
        		"	SET countterms = cte.ct\n" + 
        		"	from  cte\n" + 
        		"	where   docid= cte.id\n"
        		);
        return updated;
    }
    public  void createViewCterms() throws SQLException {
        Statement stmt = con.createStatement();
        String countdocumentTerms = "CREATE MATERIALIZED VIEW  IF NOT EXISTS  avgTerms as \n" + 
        		"	select avg(countterms) as avgterm from documents where countterms is not null\n" + 
        		"     WITH  DATA \n" ;
        
        String countdocument= "CREATE MATERIALIZED VIEW  IF NOT EXISTS  cdocs as \n" + 
        						"select count(docid) as cdoc from documents where countterms is not null\n" + 
        						"with data" ;	

        stmt.execute(countdocumentTerms);
        stmt.execute(countdocument);
    }
    public  void refreshViewCterms() throws SQLException {
        Statement stmt = con.createStatement();
        String refreshcountdocumentTerms = " REFRESH MATERIALIZED VIEW  avgTerms"  ;      
        String refreshcountdocument= "REFRESH MATERIALIZED VIEW  cdocs " ;	
        stmt.execute(refreshcountdocumentTerms);
        stmt.execute(refreshcountdocument);
    }
    
    //idf for bm25
    public int updatenewIDF() throws SQLException {
        Statement stmt = con.createStatement();
        int updated = stmt.executeUpdate("with idf as (with termdoccount as\n" + 
        		"					(select term, count(docid) as s  from features group by term)\n" + 
        		"					select termdoccount.term as term, log(((select cdocs.cdoc from 		cdocs)- termdoccount.s +0.5)/(termdoccount.s+0.5)) as nidf \n" + 
        		"						 from termdoccount)	\n" + 
        		"	UPDATE features  \n" + 
        		"	SET nidf = idf.nidf \n" + 
        		"	from  idf  \n" + 
        		"	where  features.term = idf.term\n"  );
        return updated;
    }

    //tf for bm25
    public int updatenewTF() throws SQLException {
        Statement stmt = con.createStatement();
        int updated = stmt.executeUpdate("with dtermscore as (	with cte as (select docid as id, ((( countterms*0.25\n" + 
        		"					/(select avgterm from avgTerms))+1-0.25)*1.2) as part from documents )\n" + 
        		"					\n" + 
        		"					  Select docid, term, (b.term_frequency *(0.25+1) /(b.term_frequency +  cte.part)) as nscore\n" + 
        		"					from features as b left join cte  on  cte.id = b.docid   )\n" + 
        		"	UPDATE features  \n" + 
        		"	SET ntf = dtermscore.nscore\n" + 
        		"	 from dtermscore\n" + 
        		"	where  features.term = dtermscore.term and \n" + 
        		"	features.docid = dtermscore.docid\n" );
        return updated;
    }

    //score for bm25
    public int updatenewScore() throws SQLException {
        Statement stmt = con.createStatement();
        int updated = stmt.executeUpdate("update features \n" + 
        		"set  nscore=ntf*nidf\n");
        return updated;
    } 
    public  void createscoreviews() throws SQLException {
        Statement stmt = con.createStatement();
        String tfidf = "CREATE MATERIALIZED VIEW  IF NOT EXISTS  features_tfidf as \r\n" + 
        		"select b.docid, b.term, (1 + log (b.term_frequency)) as tf, log( (select count(distinct(docid)) from documents)/\r\n" + 
        		"                ( select count(docid) from features as a where a.term = b.term)) as idf, idf*tf as score, url as url from features as b left join\r\n" + 
        		"				documents on b.docid= documents.docid\r\n" + 
        		"				order by docid" ;
        
        String okampi= "Create MATERIALIZED VIEW  IF NOT EXISTS  features_bm25 as \r\n" + 
        		"select features.docid, term ,ntf,nidf,nscore as score , url from features left join documents on features.docid = documents.docid \r\n"  ;	
        String compinedscore= "Create MATERIALIZED VIEW  IF NOT EXISTS  features_combined as \r\n" + 
        		"select features.docid, term, nscore as part1 , documents.pagerank as part2,documents.url,documents.pagerank*nscore as score  from documents, features where features.docid= documents.docid \r\n"  ;
        stmt.execute(tfidf);
        stmt.execute(okampi);
       stmt.execute(compinedscore);
    }
    public  void refreshscoreviews() throws SQLException {
        Statement stmt = con.createStatement();
        String refreshfeatures_tfidf = " REFRESH MATERIALIZED VIEW  features_tfidf"  ;      
        String refreshfeatures_bm25t= "REFRESH MATERIALIZED VIEW  features_bm25 " ;	
        String refreshfeatures_combined= "REFRESH MATERIALIZED VIEW  features_combined " ;	
        stmt.execute(refreshfeatures_tfidf);
        stmt.execute(refreshfeatures_bm25t);
        stmt.execute(refreshfeatures_combined);
    }
}


